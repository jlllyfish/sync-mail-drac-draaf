# sync-mail-aide-dger
# üöÄ Automatisation Envoi Messages DS avec GitHub Actions

Ce guide d√©taille comment automatiser l'envoi de messages par lot vers D√©marches Simplifi√©es en utilisant GitHub Actions, avec support avanc√© des formats de dates et timestamps Unix.

## üìã Table des mati√®res

- [üéØ Vue d'ensemble](#-vue-densemble)
- [‚ú® Nouveaut√©s - Gestion des dates](#-nouveaut√©s---gestion-des-dates)
- [üìÅ Structure du projet](#-structure-du-projet)
- [üîß √âtapes d'installation](#-√©tapes-dinstallation)
- [üîê Configuration des secrets GitHub](#-configuration-des-secrets-github)
- [üöÄ Utilisation](#-utilisation)
- [üìä Monitoring et logs](#-monitoring-et-logs)
- [üìÖ Gestion avanc√©e des dates](#-gestion-avanc√©e-des-dates)
- [üõ†Ô∏è D√©pannage](#Ô∏è-d√©pannage)

## üéØ Vue d'ensemble

L'automatisation permet :
- ‚úÖ **Envoi automatique** quotidien de messages √† 9h00 UTC
- ‚úÖ **D√©clenchement manuel** via l'interface GitHub
- ‚úÖ **Mode test** pour v√©rifier sans envoyer
- ‚úÖ **Mode force** pour renvoyer les messages d√©j√† envoy√©s
- ‚úÖ **Gestion intelligente des dates** avec support timestamps Unix
- ‚úÖ **Filtres avanc√©s** incluant les filtres de date
- ‚úÖ **Formatage automatique** des dates au format fran√ßais
- ‚úÖ **Gestion des erreurs** et logs d√©taill√©s
- ‚úÖ **S√©curit√©** : tokens s√©par√©s du code source

## ‚ú® Nouveaut√©s - Gestion des dates

### üîß **Support des timestamps Unix**
- **Timestamps en secondes** (10 chiffres) : `1703548800` ‚Üí `25/12/2023`
- **Timestamps en millisecondes** (13 chiffres) : `1703548800000` ‚Üí `25/12/2023`
- **Conversion automatique** dans les messages personnalis√©s
- **Filtres de date** fonctionnels sur les timestamps Grist

### üìÖ **Formats de dates support√©s**
| Format d'entr√©e | Exemple | Sortie fran√ßaise |
|----------------|---------|------------------|
| Timestamp Unix secondes | `1703548800` | `25/12/2023` |
| Timestamp Unix millisecondes | `1703548800000` | `25/12/2023` |
| Date ISO | `2023-12-25` | `25/12/2023` |
| Date fran√ßaise | `25/12/2023` | `25/12/2023` |
| DateTime ISO | `2023-12-25T14:30:00Z` | `25/12/2023` |

### üéØ **Filtres de date avanc√©s**
- **Avant le** : `date_before`
- **Apr√®s le** : `date_after`
- **Le (date exacte)** : `date_on`
- **Entre deux dates** : `date_between`
- **Support automatique** des timestamps Unix dans les filtres

## üìÅ Structure du projet

```
votre-repository/
‚îú‚îÄ‚îÄ .github/
‚îÇ   ‚îî‚îÄ‚îÄ workflows/
‚îÇ       ‚îî‚îÄ‚îÄ send-messages.yml          # üîÑ Workflow GitHub Actions
‚îú‚îÄ‚îÄ config/
‚îÇ   ‚îî‚îÄ‚îÄ public-config.json            # ‚öôÔ∏è Configuration publique (export√©e)
‚îú‚îÄ‚îÄ scripts/
‚îÇ   ‚îî‚îÄ‚îÄ send_batch.py                 # üêç Script Python d'envoi avec gestion dates
‚îú‚îÄ‚îÄ logs/                             # üìù Logs g√©n√©r√©s automatiquement
‚îÇ   ‚îú‚îÄ‚îÄ github-action.log
‚îÇ   ‚îî‚îÄ‚îÄ results-YYYYMMDD-HHMMSS.json
‚îú‚îÄ‚îÄ README.md                         # üìñ Ce fichier
‚îî‚îÄ‚îÄ requirements.txt                  # üì¶ D√©pendances (optionnel)
```

## üîß √âtapes d'installation

### √âtape 1 : Export de la configuration

1. **Lancez** votre application Flask avec les am√©liorations de dates
2. **Configurez** vos filtres de dates dans `/filters`
3. **Allez** sur la page de configuration
4. **Cliquez** sur "Exporter la configuration"
5. **T√©l√©chargez** les fichiers :
   - `public-config.json` (inclut maintenant les filtres de dates)
   - `INSTRUCTIONS-GITHUB-ACTIONS.txt`

### √âtape 2 : Cr√©er la structure GitHub

1. **Cr√©ez** un nouveau repository GitHub (ou utilisez un existant)

2. **Cr√©ez** la structure de dossiers :
   ```bash
   mkdir -p .github/workflows
   mkdir -p config
   mkdir -p scripts
   ```

3. **Placez** le fichier `public-config.json` dans le dossier `config/`

### √âtape 3 : Cr√©er le workflow GitHub Actions

Cr√©ez le fichier `.github/workflows/send-messages.yml` :

```yaml
name: üöÄ Envoi automatique de messages DS

on:
  schedule:
    # Tous les jours √† 9h00 UTC (10h00 Paris hiver, 11h00 Paris √©t√©)
    - cron: '0 9 * * *'
  workflow_dispatch:
    # Permet le d√©clenchement manuel depuis l'interface GitHub
    inputs:
      dry_run:
        description: 'üß™ Mode test (ne pas envoyer les messages)'
        required: false
        default: 'false'
        type: boolean
      force_send:
        description: 'üîÑ Forcer l\'envoi m√™me si d√©j√† envoy√©s'
        required: false
        default: 'false'
        type: boolean

env:
  PYTHON_VERSION: '3.11'

jobs:
  send-messages:
    runs-on: ubuntu-latest
    
    steps:
    - name: üì• Checkout repository
      uses: actions/checkout@v4
    
    - name: üêç Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        cache: 'pip'
    
    - name: üì¶ Install dependencies
      run: |
        python -m pip install --upgrade pip
        pip install requests python-dotenv
        # Optionnel : installer les d√©pendances depuis requirements.txt si vous en avez
        # pip install -r requirements.txt
    
    - name: üîß Verify configuration files
      run: |
        echo "üîç V√©rification des fichiers de configuration..."
        
        if [ ! -f "config/public-config.json" ]; then
          echo "‚ùå Fichier config/public-config.json manquant"
          echo "üí° Assurez-vous d'avoir export√© votre configuration depuis l'app Flask"
          exit 1
        fi
        
        if [ ! -f "scripts/send_batch.py" ]; then
          echo "‚ùå Fichier scripts/send_batch.py manquant"
          exit 1
        fi
        
        echo "‚úÖ Fichiers de configuration trouv√©s"
        
        # Afficher la config (sans les secrets)
        echo "üìã Configuration charg√©e :"
        python -c "
import json
with open('config/public-config.json', 'r') as f:
    config = json.load(f)
    print(f'  ‚Ä¢ D√©marche: {config.get(\"demarche_number\")}')
    print(f'  ‚Ä¢ Document Grist: {config.get(\"grist_doc_id\")}')
    print(f'  ‚Ä¢ Table: {config.get(\"grist_table\")}')
    print(f'  ‚Ä¢ Instructeur: {config.get(\"instructeur_id\")}')
    print(f'  ‚Ä¢ Export: {config.get(\"export_date\")}')
"
    
    - name: üîê Verify secrets
      env:
        DS_API_TOKEN: ${{ secrets.DS_API_TOKEN }}
        GRIST_API_TOKEN: ${{ secrets.GRIST_API_TOKEN }}
      run: |
        echo "üîç V√©rification des secrets GitHub..."
        
        if [ -z "$DS_API_TOKEN" ]; then
          echo "‚ùå Secret DS_API_TOKEN manquant"
          echo "üí° Ajoutez votre token DS dans GitHub Secrets"
          exit 1
        fi
        
        if [ -z "$GRIST_API_TOKEN" ]; then
          echo "‚ùå Secret GRIST_API_TOKEN manquant"
          echo "üí° Ajoutez votre token Grist dans GitHub Secrets"
          exit 1
        fi
        
        echo "‚úÖ Secrets trouv√©s"
        echo "üîê Token DS: ${DS_API_TOKEN:0:10}..."
        echo "üîê Token Grist: ${GRIST_API_TOKEN:0:10}..."
    
    - name: üìÅ Create logs directory
      run: |
        mkdir -p logs
        echo "üìÅ Dossier logs cr√©√©"
    
    - name: üöÄ Send batch messages
      env:
        DS_API_TOKEN: ${{ secrets.DS_API_TOKEN }}
        GRIST_API_TOKEN: ${{ secrets.GRIST_API_TOKEN }}
        APP_URL: ${{ secrets.APP_URL || 'http://localhost:5000' }}
        DRY_RUN: ${{ github.event.inputs.dry_run || 'false' }}
        FORCE_SEND: ${{ github.event.inputs.force_send || 'false' }}
      run: |
        echo "üöÄ D√©marrage de l'envoi par lot..."
        
        if [ "$DRY_RUN" = "true" ]; then
          echo "üß™ MODE TEST ACTIV√â - Aucun message ne sera envoy√©"
        fi
        
        if [ "$FORCE_SEND" = "true" ]; then
          echo "üîÑ MODE FORCE ACTIV√â - Renvoi des messages d√©j√† envoy√©s"
        fi
        
        python scripts/send_batch.py
    
    - name: üìä Upload results
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: send-results-${{ github.run_number }}
        path: |
          logs/
          *.log
        retention-days: 30
    
    - name: üìà Summary
      if: always()
      run: |
        echo "## üìä R√©sum√© de l'ex√©cution" >> $GITHUB_STEP_SUMMARY
        echo "- **Date:** $(date '+%d/%m/%Y %H:%M:%S')" >> $GITHUB_STEP_SUMMARY
        echo "- **Mode:** ${{ github.event.inputs.dry_run == 'true' && 'üß™ Test' || 'üöÄ Production' }}" >> $GITHUB_STEP_SUMMARY
        echo "- **Trigger:** ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
        
        if [ -f "logs/github-action.log" ]; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìù Derni√®res lignes du log:" >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
          tail -10 logs/github-action.log >> $GITHUB_STEP_SUMMARY
          echo '```' >> $GITHUB_STEP_SUMMARY
        fi
        
        # Afficher les r√©sultats s'ils existent
        if ls logs/results-*.json 1> /dev/null 2>&1; then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìä R√©sultats:" >> $GITHUB_STEP_SUMMARY
          python -c "
import json
import glob
import os

result_files = glob.glob('logs/results-*.json')
if result_files:
    latest_file = max(result_files, key=os.path.getctime)
    with open(latest_file, 'r') as f:
        results = json.load(f)
    
    print(f'- **Total trait√©:** {results.get(\"total_records\", 0)}')
    print(f'- **‚úÖ Succ√®s:** {results.get(\"success_count\", 0)}')
    print(f'- **‚ùå Erreurs:** {results.get(\"error_count\", 0)}')
    print(f'- **‚è≠Ô∏è D√©j√† envoy√©s:** {results.get(\"already_sent_count\", 0)}')
" >> $GITHUB_STEP_SUMMARY
        fi

  # Job optionnel : notification en cas d'√©chec
  notify-on-failure:
    runs-on: ubuntu-latest
    needs: send-messages
    if: failure()
    
    steps:
    - name: üìß Notification d'√©chec
      run: |
        echo "‚ùå L'envoi automatique a √©chou√©"
        echo "üîç V√©rifiez les logs dans l'onglet Actions"
        echo "üìä Les artefacts contiennent les d√©tails de l'erreur"
        
        # Ici vous pourriez ajouter une notification Slack, email, etc.
        # Exemple avec une webhook Slack :
        # curl -X POST -H 'Content-type: application/json' \
        #   --data '{"text":"‚ùå Envoi DS automatique √©chou√© - Workflow: ${{ github.run_id }}"}' \
        #   ${{ secrets.SLACK_WEBHOOK_URL }}
```

### √âtape 4 : Cr√©er le script Python

Cr√©ez le fichier `scripts/send_batch.py` avec le code fourni dans l'artefact pr√©c√©dent.

### √âtape 5 : Pousser vers GitHub

```bash
git add .
git commit -m "üöÄ Ajout automatisation GitHub Actions avec gestion des dates"
git push origin main
```

## üîê Configuration des secrets GitHub

1. **Allez** dans votre repository GitHub
2. **Cliquez** sur **Settings** ‚Üí **Secrets and variables** ‚Üí **Actions**
3. **Cliquez** sur **New repository secret**
4. **Ajoutez** ces secrets :

| Nom | Description | Valeur |
|-----|-------------|--------|
| `DS_API_TOKEN` | Token D√©marches Simplifi√©es | Votre token DS |
| `GRIST_API_TOKEN` | Token API Grist | Votre token Grist |

### ‚ö†Ô∏è Important
- **Ne jamais** committer les tokens dans le code
- **V√©rifier** que les secrets sont bien configur√©s
- **Tester** d'abord en mode dry-run

## üöÄ Utilisation

### Ex√©cution automatique
- **Planifi√©e** : Tous les jours √† 9h00 UTC automatiquement
- **Traitement intelligent** des dates et timestamps
- **Application automatique** des filtres configur√©s
- **Aucune intervention** requise

### Ex√©cution manuelle

1. **Allez** dans l'onglet **Actions** de votre repository
2. **S√©lectionnez** le workflow "üöÄ Envoi automatique de messages DS avec gestion des dates"
3. **Cliquez** sur **Run workflow**
4. **Choisissez** les options :
   - **üß™ Mode test** : Cochez pour tester sans envoyer
   - **üîÑ Mode force** : Cochez pour renvoyer les messages d√©j√† envoy√©s
5. **Cliquez** sur **Run workflow**

### Options d'ex√©cution

| Option | Description | Usage | Gestion des dates |
|--------|-------------|-------|-------------------|
| **Normal** | Envoi standard | Messages non envoy√©s uniquement | ‚úÖ Conversion automatique |
| **üß™ Test** | Mode dry-run | Teste sans envoyer r√©ellement | ‚úÖ Affichage des conversions |
| **üîÑ Force** | Renvoie tout | M√™me les messages d√©j√† envoy√©s | ‚úÖ Re-traitement des dates |

## üìä Monitoring et logs

### Visualisation des r√©sultats

1. **Onglet Actions** ‚Üí S√©lectionner l'ex√©cution
2. **Summary** : R√©sum√© rapide avec statistiques et info dates
3. **Jobs** ‚Üí **send-messages** : Logs d√©taill√©s avec traitement des dates
4. **Artifacts** : T√©l√©charger les logs complets

### Types de logs g√©n√©r√©s

```
logs/
‚îú‚îÄ‚îÄ github-action.log              # Log principal avec debug des dates
‚îî‚îÄ‚îÄ results-20240101-120000.json   # R√©sultats avec statistiques
```

### Format des r√©sultats JSON am√©lior√©

```json
{
  "total_records": 150,
  "success_count": 145,
  "error_count": 5,
  "filters_applied": true,
  "date_conversions_detected": 45,
  "details": [
    {
      "dossier_id": "12345",
      "error": "Dossier non trouv√©",
      "dates_processed": {
        "created_date": "1703548800 ‚Üí 25/12/2023",
        "sync_date": "1703635200 ‚Üí 26/12/2023"
      }
    }
  ]
}
```

## üìÖ Gestion avanc√©e des dates

### üîß **Configuration des filtres de dates**

Dans votre application Flask, configurez les filtres dans `/filters` :

```javascript
// Exemples de filtres support√©s
{
  "column": "created_date",
  "operator": "date_after", 
  "value": "2023-12-01"
}

{
  "column": "deadline", 
  "operator": "date_between",
  "value": "2023-12-01|2023-12-31"
}
```

### üìä **D√©tection automatique des colonnes**

Le script d√©tecte automatiquement les colonnes contenant des dates bas√© sur :
- **Noms de colonnes** : `date`, `created`, `updated`, `time`, `deadline`, `sync_date`
- **Contenu des champs** : Timestamps Unix, dates ISO, etc.

### üéØ **Variables dans les messages**

Les timestamps sont automatiquement convertis dans les messages :

```
Message template : "Votre dossier cr√©√© le {created_date} expire le {deadline}"
Avant : "Votre dossier cr√©√© le 1703548800 expire le 1706140800"
Apr√®s : "Votre dossier cr√©√© le 25/12/2023 expire le 25/01/2024"
```

### ‚öôÔ∏è **Configuration avanc√©e**

```json
{
  "filters": [
    {
      "column": "created_date",
      "operator": "date_after",
      "value": "2023-01-01"
    },
    {
      "column": "status",
      "operator": "equals", 
      "value": "pending"
    }
  ],
  "filter_logic": "AND",
  "message_subject": "Rappel pour {user_name} - dossier du {created_date}",
  "message_body": "Votre dossier cr√©√© le {created_date} n√©cessite une action avant le {deadline}."
}
```

## üõ†Ô∏è D√©pannage

### Erreurs courantes

#### ‚ùå "Impossible de parser la date: 1703548800"
- **Cause** : Format de timestamp non reconnu
- **Solution** : V√©rifiez que le timestamp est en secondes ou millisecondes
- **Debug** : Logs montrent les tentatives de parsing

#### ‚ùå "Filtre de date ne fonctionne pas"
- **Cause** : Mauvais format de date dans le filtre
- **Solution** : Utilisez le format YYYY-MM-DD pour les filtres
- **V√©rification** : Testez d'abord dans l'interface Flask

#### ‚ùå "Dates mal format√©es dans les messages"
- **Cause** : Variable non reconnue comme date
- **Solution** : V√©rifiez le nom de la colonne dans les mots-cl√©s de d√©tection
- **Debug** : Cherchez "üìÖ Dates d√©tect√©es" dans les logs

### Diagnostic des dates

```bash
# V√©rifier les formats de dates dans la config
cat config/public-config.json | grep -E "(date|time|created|sync)"

# Rechercher les conversions de dates dans les logs
grep "üìÖ" logs/github-action.log

# V√©rifier les filtres de dates
grep "date_" config/public-config.json
```

### Test en local des dates

```bash
# Variables d'environnement
export DS_API_TOKEN="votre_token"
export GRIST_API_TOKEN="votre_token"
export DRY_RUN="true"

# Test avec debug des dates
python -c "
from scripts.send_batch import parse_date_value, format_date_french
print('Test timestamp:', format_date_french(1703548800))
print('Test ISO:', format_date_french('2023-12-25'))
"

# Test du script complet
python scripts/send_batch.py
```

### üîç **Debugging avanc√©**

1. **Activer les logs de debug** :
   ```python
   logging.getLogger().setLevel(logging.DEBUG)
   ```

2. **V√©rifier la d√©tection des dates** :
   ```bash
   grep "Dates d√©tect√©es" logs/github-action.log
   ```

3. **Analyser les conversions** :
   ```bash
   grep "‚Üí" logs/github-action.log | head -10
   ```

### Support et contact

- **Issues GitHub** : Cr√©er une issue sur le repository
- **Logs d√©taill√©s** : Consulter les artifacts des ex√©cutions avec focus sur les dates
- **Mode debug** : Utiliser le mode test pour diagnostiquer les conversions

---

## üìã Checklist finale avec gestion des dates

- [ ] ‚úÖ Configuration export√©e depuis l'app Flask avec filtres de dates
- [ ] ‚úÖ Fichier `config/public-config.json` contient les filtres de dates
- [ ] ‚úÖ Workflow `.github/workflows/send-messages.yml` mis √† jour
- [ ] ‚úÖ Script `scripts/send_batch.py` avec gestion des dates en place
- [ ] ‚úÖ Secrets GitHub configur√©s (`DS_API_TOKEN`, `GRIST_API_TOKEN`)
- [ ] ‚úÖ Repository pouss√© sur GitHub
- [ ] ‚úÖ Test manuel r√©ussi en mode dry-run avec timestamps
- [ ] ‚úÖ V√©rification des conversions de dates dans les logs
- [ ] ‚úÖ Filtres de dates test√©s et fonctionnels
- [ ] ‚úÖ Messages avec variables de dates format√©es correctement
- [ ] ‚úÖ Premi√®re ex√©cution automatique programm√©e

## üéâ **Fonctionnalit√©s de dates disponibles**

- ‚úÖ **Support complet des timestamps Unix** (secondes et millisecondes)
- ‚úÖ **Conversion automatique** au format fran√ßais (DD/MM/YYYY)
- ‚úÖ **Filtres de dates avanc√©s** (avant, apr√®s, entre, exacte)
- ‚úÖ **Variables de dates** dans les messages personnalis√©s
- ‚úÖ **D√©tection intelligente** des colonnes de dates
- ‚úÖ **Logs d√©taill√©s** des conversions de dates
- ‚úÖ **Mode debug** pour diagnostiquer les formats
- ‚úÖ **Compatibilit√© totale** avec l'interface Flask

üéâ **Votre automatisation avec gestion avanc√©e des dates est pr√™te !** üéâ
